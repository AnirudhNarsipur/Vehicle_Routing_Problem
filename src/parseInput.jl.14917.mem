        - include("./datastructs.jl")
        - include("./utils.jl")
        - 
        - """
        - Return a  vector of distances from nodes to depot
        - """
        - function depot_distance(positions::Vector, depot_pos::Vector)
        - 
        0     c = length(positions)
      400     depot_m = zeros(c)
        0     for i = 1:c
      640         depot_m[i] = euc_dist(positions[i], depot_pos)
        -     end
        0     depot_m
        - end
        - function getSortedDemand(demand::Vector)
        0     demand_index = map(i -> (i, demand[i]), 1:length(demand))
        0     sort!(demand_index)
      512     node_dict = Dict()
     3904     for (index, elem) in enumerate(demand_index)
     1872         node_dict[elem[1]] = index
        -     end
       32     return node_dict, demand_index
        - end
        - function sorted_distance(dist_m::Matrix)
        0     l = size(dist_m)[1]
    12928     sort_m = Matrix{Tuple{Number,Number}}(undef, l, l)
        0     for i = 1:l
        0         tmp = map(j -> (dist_m[i, j], j), 1:l)
    32000         sort_m[i,:] = sort(tmp,by=i->i[1])
        -     end
        0     sort_m
        - end
        - 
        - function read_input(fl::String)
        -     try
        0         open(fl, "r") do io
     3984             lines = readlines(io)
       16             lines = [split(i) for i in lines]
      112             customers, vehicles, capacity = [parse(Int64, i) for i in lines[1]]
       16             depot_location = [floor(parse(Float64, i)) for i in lines[2][2:3]]
       48             demand = []
       48             positions = []
       64             for i = 3:length(lines)
        0                 if length(lines[i]) == 0
        -                     break
        -                 end
     2336                 push!(demand, parse(Float64, lines[i][1]))
     4864                 push!(positions, [floor(parse(Float64, lines[i][j])) for j = 2:3])
        -             end
        0             node_pos, node_demand = getSortedDemand(demand)
        0             dist_m = create_distance_matrix(positions)
       96             VRP(customers - 1, vehicles, capacity, demand, depot_location,
        -                 positions, dist_m, depot_distance(positions, depot_location),
        -                 node_pos, node_demand, sorted_distance(dist_m))
        -         end
        -     catch
        0         error("could not read file!")
        -     end
        - end
        - """
        - Get Initial feasible solution to VRP from LP solver
        - Returns matrix of VxC binary values
        - """
        - function lpSolver(vrp::VRP)
        - 
        0     model = Model(HiGHS.Optimizer)
        0     set_silent(model)
        0     C = 1:vrp.customers
        0     V = 1:vrp.vehicles
        0     mtrx = @variable(model, x[V, C], binary = true)
        0     fix(x[1,1],1,force=true)
        0     @constraint(model, [c in C], sum(x[:, c]) == 1)
        0     @constraint(model, [v in V], sum(x[v, :] .* vrp.demand) <= vrp.capacity)
        0     optimize!(model)
     4608     lpvals = zeros(vrp.vehicles, vrp.customers)
        0     for i = 1:vrp.vehicles
        0         for j = 1:vrp.customers
        0             lpvals[i, j] = value(mtrx[i, j])
        -         end
        -     end
        0     lpvals
        - end
        - """
        - Given VRP struct and LP result converts to Solution datastructure
        - """
        - function solverToSol(vars::VRP, route_mtx)::Solution
       48     routes = []
        0     for i = 1:vars.vehicles
      672         ls = []
        0         for j = 1:vars.customers
        0             if route_mtx[i, j] == 1
     1120                 push!(ls, j)
        -             end
        -         end
      416         push!(routes, ls)
        -     end
       48     route_obj = []
      512     cust_route_dict = Dict()
        0     for i=1:length(routes)
        0         route = routes[i]
        -         load = 0
      896         for j=1:length(route)
        0             cust = route[j]
        0             load += vars.demand[cust]
     2112             cust_route_dict[cust] = (i,j)
        -         end
        0         ln = length(route)
      416         push!(route_obj, Route(resize!(route, vars.customers), ln, load))
        -     end
       32     sol = Solution(route_obj, 0,cust_route_dict)
        0     sol.objective = recalc_obj_val(sol, vars)
        0     solutionCheck(sol,vars)
        0     sol
        - end
        - """
        - Return a initial feasible solution
        - """
        - function getInitialSol(vars::VRP)
        -     route_mtx = lpSolver(vars)
        -     solverToSol(vars, route_mtx)
        - end
        - 
        - function read_goog_vrp(fl::String, vars::VRP)
        -     try
        -         open(fl, "r") do io
        -             lines = readlines(io)
        -             lines = [split(i) for i in lines]
        -             objective = parse(Float64, lines[1][1])
        -             # println("i is ",lines[2][2:end-1]," length ",length(lines[2][2:end-1]))
        -             routes = [map(x -> parse(Int64, x), i[2:end-1]) for i in lines[2:end]]
        -             # println("routes are ",routes)
        -             route_obj = []
        -             for route in routes
        -                 load = 0
        -                 for cust in route
        -                     load += vars.demand[cust]
        -                 end
        -                 ln = length(route)
        -                 push!(route_obj, Route(resize!(route, vars.customers), ln, load))
        -             end
        -             sol = Solution(route_obj, objective,Dict())
        -             sol2Opt(sol,vars)
        -             sol
        -         end
        -     catch
        -         error("could not read test vrp file")
        -     end
        - end
        - 
        - function get_output(fl::String, time, sol::Solution, vars::VRP)
        -     kv_json = (k, v) -> join(['"', k, """": """, '"', v, '"'])
       48     solo = []
        0     for route in sol.routes
       80         push!(solo, "0")
        0         for i = 1:route.seqlen
     5664             push!(solo, string(route.seq[i]))
        -         end
        0         push!(solo, "0")
        -     end
     2112     out = join([
        -         "{",
        -         kv_json("Instance", basename(fl)), ",",
        -         kv_json("Time", round(time, digits=2)), ",",
        -         kv_json("Result", string(round(sol.objective, digits=2))), ",",
        -         kv_json("Solution", join(solo, " ")),
        -         "}"
        -     ])
      144     println(out)
        - end
        - 
        - function vis_output(sol::Solution, vars::VRP)
        -     lines = [string(sol.objective) * " 0"]
        -     for route in sol.routes
        -         out = "0"
        -         for i = 1:route.seqlen
        -             out *= " "
        -             out *= string(route.seq[i])
        -         end
        -         out *= " 0"
        -         push!(lines, out)
        -     end
        -     open("vistest.vrp", "w") do io
        -         for line in lines
        -             write(io, line * "\n")
        -         end
        -     end
        - end
