        - # module TRP
        - using StatsBase
        - using Random
        - include("./parseInput.jl")
        - 
        - function swapNodes(sol::Solution, vars::VRP, frloc::Number, fposloc::Number, srloc::Number, sposloc::Number)
        0     fdemand = vars.demand[sol.routes[frloc].seq[fposloc]]
        0     sdemand = vars.demand[sol.routes[srloc].seq[sposloc]]
 15620448     sol.routes[frloc].load = sol.routes[frloc].load - fdemand + sdemand
 15620448     sol.routes[srloc].load = sol.routes[srloc].load - sdemand + fdemand
 10413632     sol.nodeloc[sol.routes[frloc].seq[fposloc]] = (srloc, sposloc)
 10413632     sol.nodeloc[sol.routes[srloc].seq[sposloc]] = (frloc, fposloc)
        0     tmp = sol.routes[frloc].seq[fposloc]
        0     sol.routes[frloc].seq[fposloc] = sol.routes[srloc].seq[sposloc]
        0     sol.routes[srloc].seq[sposloc] = tmp
        0     nothing
        - end
        - 
        - function pointdistance(vars::VRP, sol::Solution, rloc::Number, rpos::Number)
        0     c = sol.routes[rloc].seq[rpos]
        0     if sol.routes[rloc].seqlen <= 1
        0         route_distance(sol.routes[rloc], vars)
        0     elseif rpos == 1
  4902240         vars.depot_distance[c] + vars.distance_m[c, sol.routes[rloc].seq[rpos+1]]
        0     elseif rpos == sol.routes[rloc].seqlen
 11643648         vars.distance_m[c, sol.routes[rloc].seq[rpos-1]] + vars.depot_distance[c]
        -     else
 14961696         vars.distance_m[c, sol.routes[rloc].seq[rpos-1]] + vars.distance_m[c, sol.routes[rloc].seq[rpos+1]]
        -     end
        - end
        - 
        - function getrandomNodeSwap(sol::Solution, vars::VRP)
        -     route_load_change = (rn, f, s) -> sol.routes[rn].load - f + s
        -     function randomNodeSwap(wghts::Weights)
        -         first, second = sample(1:vars.customers, wghts, 2, replace=false)
        -         frloc, fposloc = sol.nodeloc[first]
        -         srloc, sposloc = sol.nodeloc[second]
        -         if frloc == srloc
        -             return Inf, () -> nothing
        -         end
        -         if route_load_change(frloc, vars.demand[first], vars.demand[second]) > vars.capacity || route_load_change(srloc, vars.demand[second], vars.demand[first]) > vars.capacity
        -             return Inf, () -> nothing
        -         end
        -         oldp = pointdistance(vars, sol, frloc, fposloc) + pointdistance(vars, sol, srloc, sposloc)
        -         swapNodes(sol, vars, frloc, fposloc, srloc, sposloc)
        -         nd = pointdistance(vars, sol, frloc, fposloc) + pointdistance(vars, sol, srloc, sposloc)
        -         swapNodes(sol, vars, frloc, fposloc, srloc, sposloc)
        -         newobj = sol.objective - oldp + nd
        -         function commitChange()
        -             swapNodes(sol, vars, frloc, fposloc, srloc, sposloc)
        -             sol.objective = newobj
        -         end
        -         return newobj, commitChange
        -     end
        -     randomNodeSwap
        - end
        - function localSearch(sol::Solution, vars::VRP)::Solution
       32     numItr = 5e+4 * vars.customers
       16     sol.objective = recalc_obj_val(sol, vars)
       32     Temperature = abs(sol.objective / log(MathConstants.e, 0.97))
        -     numRuns = 1
       16     annealing_cycle = vars.customers * (vars.customers - 1) / 2
      336     best_sol = deepcopy(sol)
 10414768     prob_func = (ns) -> exp((sol.objective - ns) / Temperature)
        -     # solutionCheck(sol,vars)
      240     wghts = Weights([1 / vars.customers for _ in 1:vars.customers])
        -     route_load_change = (rn, f, s) -> sol.routes[rn].load - f + s
 23991920     for _ = 1:numItr
        0         numRuns += 1
        0         if numRuns > annealing_cycle
        -             numRuns = 1
   114272             Temperature *= 0.95
        -         end
        -         ## Random Node Swaps
        - 
 24000000         first, second = sample(1:vars.customers, wghts, 2, replace=false)
        0         frloc, fposloc = sol.nodeloc[first]
        0         srloc, sposloc = sol.nodeloc[second]
        0         if frloc == srloc
        -             continue
        -         end
 33115040         if sol[frloc].load - vars.demand[first] + vars.demand[second] > vars.capacity || sol[srloc].load -  vars.demand[second] +  vars.demand[first] > vars.capacity
        -             continue
        -         end
 34133216         oldp = pointdistance(vars, sol, frloc, fposloc) + pointdistance(vars, sol, srloc, sposloc)
 15753792         swapNodes(sol, vars, frloc, fposloc, srloc, sposloc)
 34133216         nd = pointdistance(vars, sol, frloc, fposloc) + pointdistance(vars, sol, srloc, sposloc)
  5251264         nscore = sol.objective - oldp + nd
        0         if nscore < best_sol.objective
   460656             best_sol = deepcopy(sol)
        -             continue
  7811088         elseif rand() <= prob_func(nscore)
        -             continue
        -         else
 39486976             swapNodes(sol, vars, frloc, fposloc, srloc, sposloc)
        -         end
        -     end
        0     sol2Opt(best_sol, vars)
        -     # solutionCheck(best_sol,vars)
        0     best_sol
        - end
        - """
        - Returns a lm fraction of the nearest neighbors of a random node
        - """
        - function nn_cluster(vars::VRP, lm::Float64)
        -     numtake = Int(round(lm * vars.customers))
        -     cent = rand(1:vars.customers)
        -     cust_d = [(i, vars.distance_m[cent, i]) for i in 1:vars.customers]
        -     sort!(cust_d, by=x -> x[2])
        -     map(x -> x[1], cust_d[1:numtake])
        - end
        - function destroy_tsp(sol::Solution, vrp::VRP, remove_c)
        -     model = Model(HiGHS.Optimizer)
        -     set_silent(model)
        -     C = 1:vrp.customers
        -     V = 1:vrp.vehicles
        -     mtrx = @variable(model, x[V, C], binary = true)
        -     @constraint(model, [c in C], sum(x[:, c]) == 1)
        -     @constraint(model, [v in V], sum(x[v, :] .* vrp.demand) <= vrp.capacity)
        -     min_expr = @expression(model, 0)
        -     cust_routes = get_customer_routes(sol)
        -     for c in C
        -         curr_route = cust_routes[c]
        -         if !(c in remove_c)
        -             @constraint(model, x[curr_route, c] == 1)
        -         else
        -             min_expr += @expression(model, x[curr_route, c])
        -         end
        -     end
        -     @objective(model, Min, min_expr)
        -     optimize!(model)
        -     lpvals = zeros(Int8, vrp.vehicles, vrp.customers)
        -     changes = 0
        -     for j = 1:vrp.customers
        -         curr_route = cust_routes[j]
        -         for i = 1:vrp.vehicles
        -             lpvals[i, j] = Int(round(value(mtrx[i, j])))
        -             if j in remove_c && curr_route == i && lpvals[i, j] == 0
        -                 changes += 1
        -             end
        -         end
        -     end
        -     println(" num changes are : ", changes, " out of ", length(remove_c))
        -     nsol = solverToSol(vrp, lpvals)
        -     sol2Opt(nsol, vrp)
        -     println("before local search ", nsol.objective)
        -     lnsol = localSearch(nsol, vrp)
        -     println("final objective is ", lnsol.objective)
        -     lnsol
        - end
        - function n_rand_groups(vars::VRP, g::Number)
        -     cust = shuffle(1:vars.customers)
        -     take = Int(round(vars.customers / g))
        -     ls = []
        -     i = 1
        -     while i <= length(cust)
        -         if i + take <= length(cust)
        -             push!(ls, cust[i:i+take])
        -             i += (take + 1)
        -         else
        -             push!(ls, cust[i:end])
        -             break
        -         end
        -     end
        -     ls
        - end
        - function fulldestroy(fl::String)
        -     vars = read_input(fl)
        -     sol = getInitialSol(vars)
        -     sol = localSearch(sol, vars)
        -     println("starting sol ", sol.objective)
        -     # groups = n_rand_groups(vars,3)
        -     take = Int(round(0.95 * vars.customers))
        -     # group = sample(1:vars.customers,take,replace=false)
        -     # group = map(x -> x[1] ,vars.node_demand[1:take])
        -     group = get_closest_routes(sol, vars)
        -     vis_output(sol, vars)
        -     return nothing
        -     println("rebuilding with close routes")
        -     sol = destroy_tsp(sol, vars, group)
        - 
        -     println("new sol ", sol.objective)
        -     vis_output(sol, vars)
        - end
        - """
        - K Mean Clustering with v (num vehicles) clusters with v random customers as 
        - centers
        - Does not respect load
        - """
        - function nn_to_lpmatrix(vars::VRP)
        -     solMat = zeros(Bool, vars.vehicles, vars.customers)
        -     centers = sample(1:vars.customers, vars.vehicles, replace=false)
        -     foreach(t -> solMat[t[1], t[2]] = 1, enumerate(centers))
        -     cust = filter(i -> !(i in centers), 1:vars.customers)
        -     for c in cust
        -         argmin, min = 1, Inf
        -         for (i, center) in enumerate(centers)
        -             if vars.distance_m[c, center] < argmin
        -                 argmin, min = i, vars.distance_m[c, center]
        -             end
        -         end
        -         solMat[argmin, c] = 1
        -     end
        -     solMat
        - end
        - function nn_based(sol::Solution, vrp::VRP)
        -     nnMat = nn_to_lpmatrix(vrp) .+ 1
        -     remove_c = sample(1:vrp.customers, Int(round(1 * vrp.customers)), replace=false)
        -     model = Model(HiGHS.Optimizer)
        -     set_silent(model)
        -     C = 1:vrp.customers
        -     V = 1:vrp.vehicles
        -     mtrx = @variable(model, x[V, C], binary = true)
        -     @constraint(model, [c in C], sum(x[:, c]) == 1)
        -     @constraint(model, [v in V], sum(x[v, :] .* vrp.demand) <= vrp.capacity)
        -     cust_routes = get_customer_routes(sol)
        -     remove_mat = zeros(vrp.vehicles, vrp.customers)
        -     obj_expr = @expression(model, 0)
        -     for c in remove_c
        -         curr_route = cust_routes[c]
        -         obj_expr += @expression(model, x[curr_route, c])
        -     end
        -     @objective(model, Min, sum(nnMat .- x))
        -     optimize!(model)
        -     lpvals = zeros(vrp.vehicles, vrp.customers)
        -     for i = 1:vrp.vehicles
        -         for j = 1:vrp.customers
        -             lpvals[i, j] = value(mtrx[i, j])
        -         end
        -     end
        -     nsol = solverToSol(vrp, lpvals)
        -     sol2Opt(nsol, vrp)
        -     lnsol = localSearch(nsol, vrp)
        -     sol2Opt(lnsol, vrp)
        -     lnsol
        - end
        - 
        - function route_center(route::Route, vars::VRP)
        -     cx, cy = 0, 0
        -     for i = 1:route.seqlen
        -         cx += vars.positions[route[i]][1]
        -         cy += vars.positions[route[i]][2]
        -     end
        -     [cx / route.seqlen, cy / route.seqlen]
        - end
        - function average_center_distance(route::Route, center::Vector, vars::VRP)
        -     dist = 0
        -     for i = 1:route.seqlen
        -         dist += euc_dist(vars.positions[route[i]], center)
        -     end
        -     dist / route.seqlen
        - end
        - function get_closest_routes(sol::Solution, vars::VRP)
        -     centers = map(i -> route_center(sol[i], vars), 1:vars.vehicles)
        -     centerDists = map(i -> (i, average_center_distance(sol[i], centers[i], vars)), 1:vars.vehicles)
        -     sort!(centerDists, by=i -> i[2])
        -     randRoute = centerDists[end][1]
        -     println("center is ", randRoute)
        -     routeDist = map(i -> (i, euc_dist(centers[randRoute], centers[i])), 1:vars.vehicles)
        -     sort!(routeDist, by=i -> i[2])
        -     closeRoutes = map(i -> i[1], routeDist)[1:3]
        -     println("closest routes are ", closeRoutes)
        -     remove_c = []
        -     for r in closeRoutes
        -         x = sol[r].seq[2:sol[r].seqlen]
        -         append!(remove_c, x)
        -     end
        -     remove_c
        - end
        - 
        - 
        - 
        - function mn(fl::String)
        0     start_time = Base.Libc.time()
        0     vars = read_input(fl)
        0     sol = getInitialSol(vars)
        0     sol2Opt(sol, vars)
        0     org_d = sol.objective
        -     numRuns = 1
        -     bestsol = sol
        0     for i = 1:numRuns
      336         tmp = deepcopy(sol)
        -         # tmp = deepcopy(destroy_tsp(tmp,vars))
        0         tmp = localSearch(tmp, vars)
        -         # println("objective is ",tmp.objective)
       16         tmp.objective = recalc_obj_val(tmp, vars)
        0         if tmp.objective < bestsol.objective
      336             bestsol = deepcopy(tmp)
        -         end
        -     end
        0     f_d = bestsol.objective
        0     end_time = Base.Libc.time()
      128     println("initial obj is ", org_d, " final is ", f_d, " improv is ", round(((org_d - f_d) / org_d) * 100, digits=2), "%")
        0     vis_output(bestsol, vars)
        0     get_output(fl, end_time - start_time, bestsol, vars)
        - 
        - end
        - 
        - # function __init__()
        - #     mn(ARGS[1])
        - # end
        - # end
